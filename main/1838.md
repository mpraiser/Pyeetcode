# 1838：排序+二分法

## 特性1：只有小于等于最终众数的元素才会操作

可进行的操作是：$x \rightarrow x + 1$，只能变大。

那么如果已知众数$y$，只有小于等于$y$的$x$才能变为$y$，需要花费$y-x$步操作。

## 猜想1：操作后的众数一定在$nums$中

设操作后的众数为$z$：

1. 如果$z < \min(nums)$，显然不成立；

2. 如果$z = \min(nums)$，则$z$在$nums$中；

3. 如果$z > \min(nums)$，分析如下：

设$nums$中最大的小于$z$的元素为$y$，所有进行了$n_i \rightarrow z$变换的元素$n_i$有

$$\sup\{n_i\} = y$$

那么变换可以视作$n_i \rightarrow y \rightarrow z$，其中$y \rightarrow z$仅带来了更多的操作量，而众数只不过全体换了一个值，所以在给定操作数量限制的前提下一定有一样好或者更好的解$y$。

## 目标函数

由[猜想1](#猜想1)可知，众数一定在$nums$中，因此我们可以遍历$nums$中的所有元素作为众数进行搜索；由于[特性1](#特性1)，我们需要方便的获得元素间的大小关系，因此先对$nums$进行排序。

从最大频次的目标来考虑，选择数组中最大的元素是最有可能得到最大值的，因此采用倒序：

```py
nums.sort(reverse=True)
```

从贪心的角度考虑，越接近选择的众数$n_j$的元素变化的代价越小，因此从最邻近$n_j$的元素逐个考虑加入。

现在的满足要求的条件是：

$$\sum_{i = j}^t (n_j - n_i) \leq k$$

$t$是要搜索的右边界，在区间$[j, t]$中的元素均会被变化为众数$n_j$，最终频次为区间内元素数量：

$$t - j + 1$$

由于在上式中，一定有$n_j \geq n_i$，因此

$$f(t) = \sum_{i = j}^t (n_j - n_i)$$

是一个关于$t$的递增（有序）序列，所以可以采用二分搜索。

## 优化计算：前缀和

其中又有


$$\begin{aligned}
f(t) &= \sum_{i = j}^t (n_j - n_i)\\
&= \sum_{i = j}^t n_j - \sum_{i = j}^t n_i
\end{aligned}$$

由于$n_j$为常数，有

$$\sum_{i = j}^t n_j = (t - j + 1) n_j$$

$\displaystyle\sum_{i = j}^t n_i$为前缀和的形式，可以$O(1)$地得到：

$$
\sum_{i = j}^t n_i = 
\left\{\begin{aligned}
&\text{psum}[t] - \text{psum}[j-1] &, j \geq 1 \\
&\text{psum}[t] &,  j =0 
\end{aligned}\right.
$$

## 复杂度
排序时间复杂度为$O(n \log n)$，遍历所有元素+二分查找复杂度为$O(n \log n)$，总时间复杂度为$O(n \log n)$